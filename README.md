|||
|---|---|
|ДИСЦИПЛИНА|Фронтенд и бэкенд разработка|
|ИНСТИТУТ|ИПТИП|
|КАФЕДРА|Индустриального программирования|
|ВИД УЧЕБНОГО МАТЕРИАЛА|Методические указания к практическим занятиям|
|ПРЕПОДАВАТЕЛЬ|Астафьев Рустам Уралович|
|СЕМЕСТР|2 семестр, 2024/2025 уч. год|

---

### **Практическое занятие 17: Service Worker**

#### **Введение**  
Service Worker — это ключевая технология, лежащая в основе прогрессивных веб-приложений (PWA). Он действует как прокси-сервер между браузером и сетью, позволяя контролировать обработку запросов, кэшировать ресурсы и обеспечивать работу приложения в офлайн-режиме. На этом занятии мы подробно разберём, как зарегистрировать Service Worker, настроить кэширование статических файлов и организовать базовую офлайн-работу приложения.  

#### **Теоретическая основа**  
Service Worker работает в отдельном потоке и не имеет прямого доступа к DOM, но может взаимодействовать со страницами через сообщения (postMessage) и управлять сетевыми запросами. Его жизненный цикс состоит из нескольких этапов: регистрация, установка, активация и управление fetch-событиями.  

Важно понимать, что Service Worker требует HTTPS-соединения в production-среде, хотя для локальной разработки достаточно `http://localhost`. Также Service Worker действует в пределах своей зоны видимости (scope), которая определяется местом его расположения. Например, если SW лежит в папке `/sw/`, он не сможет управлять запросами на уровне корня сайта.  

#### **Практическая часть: создание и регистрация Service Worker**  
Для начала создадим простое веб-приложение с базовой структурой:  

**Файловая структура:**  
```
/project  
  ├── index.html  
  ├── app.js  
  └── sw.js  ← Service Worker  
```  

**index.html**  
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Service Worker Demo</title>
</head>
<body>
    <h1>Добро пожаловать в офлайн-приложение!</h1>
    <script src="app.js"></script>
</body>
</html>
```  

**app.js**  
```javascript
// Регистрация Service Worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
        try {
            const registration = await navigator.serviceWorker.register('/sw.js');
            console.log('ServiceWorker зарегистрирован:', registration.scope);
        } catch (err) {
            console.error('Ошибка регистрации:', err);
        }
    });
}
```  

**sw.js**  
```javascript
const CACHE_NAME = 'my-cache-v1';
const ASSETS = [
    '/',
    '/index.html',
    '/app.js'
];

// Установка Service Worker и кэширование ресурсов
self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(ASSETS))
            .then(() => self.skipWaiting())
    );
});

// Активация и очистка старых кэшей
self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(keys => {
            return Promise.all(
                keys.filter(key => key !== CACHE_NAME)
                    .map(key => caches.delete(key)))
        })
    );
});

// Перехват запросов и возврат из кэша
self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => response || fetch(event.request))
    );
});
```  

#### **Разбор кода**  

1. **Регистрация (app.js)**  
   Проверяем поддержку `serviceWorker` в браузере и регистрируем файл `sw.js`. Важно делать это после полной загрузки страницы (`window.onload`), чтобы не конкурировать с другими ресурсами.  

2. **Установка (sw.js)**  
   На этапе `install` мы создаём кэш с именем `my-cache-v1` и сохраняем в него все статические файлы. Метод `skipWaiting()` принудительно активирует новый Service Worker без ожидания.  

3. **Активация (sw.js)**  
   При активации удаляются старые версии кэша, чтобы избежать конфликтов.  

4. **Перехват запросов (sw.js)**  
   Событие `fetch` перехватывает все запросы. Если ресурс есть в кэше — возвращаем его, иначе загружаем из сети.  

#### **Тестирование**  
1. Запустите проект через локальный сервер (например, `http-server` или `Live Server` в VS Code).  
2. Откройте Chrome DevTools (`F12`) → вкладка **Application** → **Service Workers**.  
3. Проверьте, что SW зарегистрирован и активирован.  
4. Перейдите в **Cache Storage** и убедитесь, что файлы закэшированы.  
5. Включите офлайн-режим (в DevTools: **Network → Offline**) и обновите страницу. Приложение должно работать!  

#### **Возможные ошибки**  
- **Ошибка регистрации:** Убедитесь, что SW лежит в корне (или scope указан явно).  
- **Кэш не обновляется:** Измените `CACHE_NAME`, чтобы триггерить новую установку.  
- **Не кэшируется HTML:** Добавьте `'/'` в `ASSETS` для главной страницы.  

#### **Заключение**  
Теперь ваше приложение может работать offline! Дальше можно улучшить логику:  
- Динамически кэшировать новые запросы.  
- Использовать `Workbox` для упрощения кэширования.  
- Реализовать стратегии "Cache First" или "Network First".  
